package otmp

use core {package, io, tprintf, iter, Optional}
use core.misc {
    as_any,
    any_iter,
    any_dereference,
    any_selector,
    any_subscript
}

#package
TemplateRenderer :: struct {
    t: &Template;
    w: &io.Writer;
    reg: &TemplateRegistry;

    scope: &TemplateScope;
    blocks: Map(str, &TNode);

    error: str;
}

#package
render_template :: (use r: &TemplateRenderer) -> Error {
    return render_instructions(r, t.instructions);
}

#local
render_instructions :: (use r: &TemplateRenderer, instrs: [..] &TNode) -> Error {
    for instrs {
        switch it {
            case .Text => text do io.write_str(w, text);

            case .Block => &block {
                if blocks->has(block.block_name) {
                    error = tprintf("Block '{}' defined multiple times.");
                    return .Render_Error;
                }

                blocks[block.block_name] = it;
            }

            case .Extend => template_name {
                template := reg->get_template(template_name);
                if template == null {
                    error = tprintf("Template '{}' not found.");
                    return .Render_Error;
                }

                if err := render_instructions(r, template.instructions); err != .None {
                    return err;
                }
            }

            case .Foreach => &for_node {
                // :Temporary :TemplateVariables
                var := for_node.list;
                if var.tag != .ExprVar {
                    error = tprintf("Expected variable as for-iterator.");
                    return .Render_Error;
                }

                var_name := union_as_ptr(var, .ExprVar).var_name;

                scope->get(var_name)->with([var] {
                    for any_iter(var) {
                        scope->put(for_node.var_name, it);

                        if err := render_instructions(r, for_node.body); err != .None {
                            return err;
                        }
                    }

                    scope->delete(for_node.var_name);
                });
            }

            case .ExprBlock => &block {
                blocks->get(block.block_name)->with([the_block] {
                    if err := render_instructions(r, union_as_ptr(the_block, .Block).contents); err != .None {
                        return err;
                    }
                });
            }

            case .ExprPartial => &partial {
                template := reg->get_template(partial.partial_name);
                if !template {
                    continue;
                }

                for iter.as_iter(partial.arguments)
                    |> iter.enumerate()
                {
                    // ROBUSTNESS: Normally, allocating to a temporary allocator for
                    // something stored in a map is a bad idea, but here, because the
                    // map is only used within this function, so long as the temporary
                    // allocator is never cleared, there is nothing wrong with using
                    // tprintf.
                    val := resolve_expr_to_any(r, it.value);
                    if val {
                        scope->put(tprintf("{}", it.index), val->unwrap());
                    }
                }

                if err := render_instructions(r, template.instructions); err != .None {
                    return err;
                }
            }

            case .ExprVar, .ExprSelector, .ExprSubscript {
                var := resolve_expr_to_any(r, cast(&TNode) it);
                if !var do continue;

                // There are weird bugs related to Optional any's (? any), where
                // the wrong any is returned. Unwrapping as a pointer fixes this
                // bug.
                value := var->unwrap_ptr();
                io.write_format_va(w, "{}", .[*value]);
            }

            case #default {
                error = tprintf("Unhandled node type '{}'", it.tag);
                return .Render_Error;
            }
        }
    }

    return .None;
}

#local
resolve_expr_to_any :: (use r: &TemplateRenderer, expr: &TNode) -> ? any {
    switch expr {
        case .ExprVar => &var {
            return scope->get_opt(var.var_name);
        }

        case .ExprSelector => &selector {
            return resolve_expr_to_any(r, selector.var)?
                |> any_dereference()
                |> any_selector(selector.field);
        }

        case .ExprSubscript => &subscript {
            sub_any := resolve_expr_to_any(r, subscript.var)?;
            sub := resolve_expr_to_any(r, subscript.sub)->and_then(any_to_int);
            switch sub {
                case .Some => v do return any_subscript(sub_any, ~~ v);
                case #default do return .{};
            }
        }

        case .ExprInt => &int do return as_any(&int.val);

        case .ExprString => &string do return as_any(&string.val);

        case #default do return .{};
    }
}


#local
// :StandardLibrary
any_to_int :: (v: any) -> ? i64 {
    switch v.type {
        C(u32);
        C(i32);
        C(u64);
        C(i64);

        C :: macro (T: type_expr) {
            case T do return cast(i64, *cast(&T) v.data);
        }
    }

    return .{};
}
